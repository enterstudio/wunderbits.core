<!DOCTYPE html>

<html>
<head>
  <title>WBEvents.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="WBClass.html">
                WBClass.js
              </a>
            
              
              <a class="source" href="WBDeferred.html">
                WBDeferred.js
              </a>
            
              
              <a class="source" href="WBEvents.html">
                WBEvents.js
              </a>
            
              
              <a class="source" href="WBMixin.html">
                WBMixin.js
              </a>
            
              
              <a class="source" href="WBSingleton.html">
                WBSingleton.js
              </a>
            
              
              <a class="source" href="define.html">
                define.js
              </a>
            
              
              <a class="source" href="assert.html">
                assert.js
              </a>
            
              
              <a class="source" href="clone.html">
                clone.js
              </a>
            
              
              <a class="source" href="createUID.html">
                createUID.js
              </a>
            
              
              <a class="source" href="extend.html">
                extend.js
              </a>
            
              
              <a class="source" href="merge.html">
                merge.js
              </a>
            
              
              <a class="source" href="toArray.html">
                toArray.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>WBEvents.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>define([

  <span class="string">'./lib/assert'</span>,
  <span class="string">'./lib/toArray'</span>

], <span class="function"><span class="keyword">function</span> <span class="params">(assert, toArray)</span> {</span>

  <span class="string">'use strict'</span>;

  <span class="keyword">var</span> eventSplitter = <span class="regexp">/\s+/</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>blah blah</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> validationErrors = {
    <span class="string">'trigger'</span>: <span class="string">'Cannot trigger event(s) without event name(s)'</span>,
    <span class="string">'events'</span>: <span class="string">'Cannot bind/unbind without valid event name(s)'</span>,
    <span class="string">'callback'</span>: <span class="string">'Cannot bind/unbind to an event without valid callback'</span>
  };

  <span class="keyword">var</span> Events = {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Bind an event to a <code>callback</code> function. Passing <code>&quot;all&quot;</code> will bind
the callback to all events fired.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    on: <span class="function"><span class="keyword">function</span><span class="params">(name, callback, context)</span> {</span>
      <span class="keyword">var</span> handler = eventsApi(<span class="keyword">this</span>, <span class="string">'on'</span>, name, [callback, context]);
      <span class="keyword">if</span> (!handler || !callback) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">this</span>._events || (<span class="keyword">this</span>._events = {});
      <span class="keyword">var</span> events = <span class="keyword">this</span>._events[name] || (<span class="keyword">this</span>._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || <span class="keyword">this</span>});
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Remove one or many callbacks. If <code>context</code> is null, removes all
callbacks with that function. If <code>callback</code> is null, removes all
callbacks for the event. If <code>name</code> is null, removes all bound
callbacks for all events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="string">'off'</span>: <span class="function"><span class="keyword">function</span><span class="params">(name, callback, context)</span> {</span>
      <span class="keyword">var</span> retain, ev, events, names, i, l, j, k;
      <span class="keyword">var</span> handler = eventsApi(<span class="keyword">this</span>, <span class="string">'off'</span>, name, [callback, context]);
      <span class="keyword">if</span> (!<span class="keyword">this</span>._events || !handler) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">if</span> (!name &amp;&amp; !callback &amp;&amp; !context) {
        <span class="keyword">this</span>._events = {};
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }
      names = name ? [name] : Object.keys(<span class="keyword">this</span>._events);
      <span class="keyword">for</span> (i = <span class="number">0</span>, l = names.length; i &lt; l; i++) {
        name = names[i];
        events = <span class="keyword">this</span>._events[name];
        <span class="keyword">if</span> (events) {
          <span class="keyword">this</span>._events[name] = retain = [];
          <span class="keyword">if</span> (callback || context) {
            <span class="keyword">for</span> (j = <span class="number">0</span>, k = events.length; j &lt; k; j++) {
              ev = events[j];
              <span class="keyword">if</span> ((callback &amp;&amp; callback !== ev.callback &amp;&amp;
                   callback !== ev.callback._callback) ||
                  (context &amp;&amp; context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          <span class="keyword">if</span> (!retain.length) <span class="keyword">delete</span> <span class="keyword">this</span>._events[name];
        }
      }

      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Trigger one or many events, firing all bound callbacks. Callbacks are
passed the same arguments as <code>trigger</code> is, apart from the event name
(unless you&#39;re listening on <code>&quot;all&quot;</code>, which will cause your callback to
receive the true name of the event as the first argument).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    trigger: <span class="function"><span class="keyword">function</span><span class="params">(name)</span> {</span>
      <span class="keyword">if</span> (!<span class="keyword">this</span>._events) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">var</span> args = [].slice.call(arguments, <span class="number">1</span>);
      <span class="keyword">if</span> (!eventsApi(<span class="keyword">this</span>, <span class="string">'trigger'</span>, name, args)) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">var</span> events = <span class="keyword">this</span>._events[name];
      <span class="keyword">var</span> allEvents = <span class="keyword">this</span>._events.all;
      <span class="keyword">if</span> (events) triggerEvents(events, args);
      <span class="keyword">if</span> (allEvents) triggerEvents(allEvents, arguments);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Implement fancy features of the Events API such as multiple event
names <code>&quot;change blur&quot;</code> and jQuery-style event maps <code>{change: action}</code>
in terms of the existing API.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> eventsApi = <span class="function"><span class="keyword">function</span><span class="params">(obj, action, name, rest)</span> {</span>
    <span class="keyword">if</span> (!name) <span class="keyword">return</span> <span class="literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Handle event maps.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'object'</span>) {
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Handle space separated event names.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (eventSplitter.test(name)) {
      <span class="keyword">var</span> names = name.split(eventSplitter);
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = names.length; i &lt; l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">return</span> <span class="literal">true</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>A difficult-to-believe, but optimized internal dispatch function for
triggering events. Tries to keep the usual cases speedy (most internal
Backbone events have 3 arguments).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> triggerEvents = <span class="function"><span class="keyword">function</span> <span class="params">(events, args)</span> {</span>
    <span class="keyword">var</span> ev, i = -<span class="number">1</span>, l = events.length, a1 = args[<span class="number">0</span>], a2 = args[<span class="number">1</span>], a3 = args[<span class="number">2</span>];
    <span class="keyword">switch</span> (args.length) {
      <span class="keyword">case</span> <span class="number">0</span>:
        <span class="keyword">while</span> (++i &lt; l) {
          (ev = events[i]).callback.call(ev.ctx);
        }
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">1</span>:
        <span class="keyword">while</span> (++i &lt; l) {
          (ev = events[i]).callback.call(ev.ctx, a1);
        }
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">2</span>:
        <span class="keyword">while</span> (++i &lt; l) {
          (ev = events[i]).callback.call(ev.ctx, a1, a2);
        }
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">3</span>:
        <span class="keyword">while</span> (++i &lt; l) {
          (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
        }
        <span class="keyword">break</span>;
      <span class="keyword">default</span>:
        <span class="keyword">while</span> (++i &lt; l) {
          (ev = events[i]).callback.apply(ev.ctx, args);
        }
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Aliases for backwards compatibility.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.bind   = Events.on;
  Events.unbind = Events.off;

  return {

    '_eventArgsMap': {},

    'on': function (events, callback, context) {

      var self = this;

      assert.string(events, validationErrors.events);
      assert.function(callback, validationErrors.callback);

      self.iterateOverEvents(events, function (event) {
        var args = self._eventArgsMap[event];
        args &amp;&amp; callback.apply(context || self, args);
      });

      Events.on.apply(this, arguments);

      return self;
    },

    'trigger': function (events) {

      assert.string(events, validationErrors.trigger);

      var self = this;
      var params = toArray(arguments);
      self.iterateOverEvents(events, self.triggerEvent, params);
      return self;
    },

    'triggerEvent': function (eventName, params) {

      var self = this;
      var channelName = '';
      var queue = [];
      var storedFragments;
      var message, part, fragments;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Iterate the parts of the eventName to create
a queue of all channels to trigger event on</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> channelFragments = eventName.split(<span class="string">':'</span>);
      <span class="keyword">while</span> (channelFragments.length) {
        part = channelFragments.shift();
        message = {};
        <span class="keyword">if</span> (channelName) {
          channelName += <span class="string">':'</span>;
        }
        channelName += part;

        fragments = storedFragments || channelFragments;
        storedFragments = fragments.slice(<span class="number">1</span>);
        message.fragments = storedFragments;
        message.channel = channelName;

        queue.push(message);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Reverse the queue, to make sure &quot;bubbling&quot;
occurs from inside out, up to the parent channel</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      queue.reverse();
      <span class="keyword">while</span> (queue.length) {

        message = queue.shift();</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Always send the current channel name
as the first argument, to be triggered</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        fragments = [message.channel];</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Put the arguments back together with
the fragment as the second argument
This will work recursively,
pushing the fragments onto the arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (message.fragments.length) {
          fragments.push(message.fragments);
        }
        fragments.push.apply(fragments, params.slice(<span class="number">1</span>));

        Events.trigger.apply(self, fragments);
      }

      <span class="keyword">var</span> args = [eventName].concat(params.slice(<span class="number">1</span>));
      self.triggered &amp;&amp; self.triggered.apply(self, args);
    },

    <span class="string">'off'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(events)</span> {</span>

      <span class="keyword">var</span> self = <span class="keyword">this</span>;

      events &amp;&amp; assert.string(events, validationErrors.events);</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>backbone has a funny way of unbinding events, looping
the whole list and then applying #on on the events that
shouldn&#39;t be unbound - so, we have to temporarily replace
self&#39;s #on, since the on method will re-trigger any
published event...</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> _on = self.on;
      self.on = Events.on;
      Events.off.apply(self, arguments);
      self.on = _on;

      <span class="keyword">return</span> self;
    },

    <span class="string">'once'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>

      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="keyword">var</span> args = toArray(arguments);
      <span class="keyword">var</span> callback = args[<span class="number">1</span>];

      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) {
        args[<span class="number">1</span>] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
          Events.off.apply(self, args);
          callback.apply(args[<span class="number">2</span>] || self, arguments);
        };
      }

      self.on.apply(self, args);

      <span class="keyword">return</span> self;
    },

    <span class="string">'publish'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(events)</span> {</span>

      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);

      assert.string(events, validationErrors.events);

      self.iterateOverEvents(events, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> {</span>

        <span class="keyword">if</span> (!self._eventArgsMap[event]) {
          self._eventArgsMap[event] = args;
          <span class="keyword">var</span> payload = [event].concat(args);
          Events.trigger.apply(self, payload);
        }
      });

      <span class="keyword">return</span> self;
    },

    <span class="string">'unpublish'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(events)</span> {</span>

      <span class="keyword">var</span> self = <span class="keyword">this</span>;

      assert.string(events, validationErrors.events);

      self.iterateOverEvents(events, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> {</span>
        <span class="keyword">delete</span> self._eventArgsMap[event];
      });

      <span class="keyword">return</span> self;
    },

    <span class="string">'unpublishAll'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>

      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      self._eventArgsMap = {};
      <span class="keyword">return</span> self;
    },

    <span class="string">'iterateOverEvents'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(events, callback)</span> {</span>

      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="keyword">var</span> eventsArray = events.split(eventSplitter);
      <span class="keyword">var</span> args = toArray(arguments, <span class="number">2</span>);
      args.unshift(<span class="literal">null</span>);

      <span class="keyword">while</span> (eventsArray.length) {
        args[<span class="number">0</span>] = eventsArray.shift();
        callback.apply(self, args);
      }
    }
  };
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
